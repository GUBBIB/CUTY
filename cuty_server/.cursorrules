// 범용적 Flask 백엔드 아키텍처
- Python과 Flask 웹 프레임워크 기반의 RESTful API 서버 구현
- SQLAlchemy ORM을 사용한 데이터베이스 모델링 및 관리
- Flask-Migrate를 사용한 데이터베이스 마이그레이션 관리
- JWT(JSON Web Token) 기반의 인증 시스템 
- Zappa를 활용한 AWS Lambda 서버리스 배포
- 환경 변수를 통한 다중 환경 설정 관리 (.env, .env.local, .env.prod)

// 앱 진입점 예시 (app.py)
```python
from flask import Flask
from flask_migrate import Migrate
import logging
from src.models import db
from src.routes import init_routes
from src.config.env import SECRET_KEY, FLASK_ENV, DEBUG
from src.config.database import DatabaseConfig

def create_app(config_name='local'):
    app = Flask(__name__)
    app.config.from_object(DatabaseConfig())
    app.config['SECRET_KEY'] = SECRET_KEY
    app.config['DEBUG'] = DEBUG
    
    # 로깅 설정
    if DEBUG:
        app.logger.setLevel(logging.DEBUG)
    
    db.init_app(app)
    Migrate(app, db)
    
    # 라우트 등록
    init_routes(app)
    
    return app

app = create_app(FLASK_ENV)

if __name__ == '__main__':
    app.run()
```

// 모듈화된 디렉토리 구조
- src/models: 데이터베이스 모델 정의
- src/routes: API 엔드포인트 라우트 정의 (버전별, 관리자/사용자 분리)
- src/services: 비즈니스 로직 처리
- src/utils: 공통 유틸리티 함수
- src/config: 환경 설정 및 구성

// 라우트 초기화 예시 (src/routes/__init__.py)
```python
from flask import Blueprint
from src.routes.v1.auth_routes import auth_bp
from src.routes.v1.user_routes import user_bp
from src.routes.v1.post_routes import post_bp
from src.routes.admin.admin_routes import admin_bp

def init_routes(app):
    # API v1 경로
    v1_bp = Blueprint('v1', __name__, url_prefix='/v1')
    v1_bp.register_blueprint(auth_bp, url_prefix='/auth')
    v1_bp.register_blueprint(user_bp, url_prefix='/users')
    v1_bp.register_blueprint(post_bp, url_prefix='/posts')
    
    # 관리자 경로
    app.register_blueprint(admin_bp, url_prefix='/admin')
    
    # API 버전 등록
    app.register_blueprint(v1_bp)
```

// 데이터베이스 모델 아키텍처
- 기본 TimestampMixin 상속을 통한 생성/수정 시간 자동 관리
- 논리적 삭제(soft delete) 구현 - deleted_at 필드와 is_deleted 속성 활용
- 계층적 데이터 모델링 (부모-자식 관계)
- 자기 참조 관계 구현 (대댓글 시스템)
- 다대다 관계 구현 (좋아요, 조회수 등)

// 기본 모델 믹스인 예시 (src/models/base.py)
```python
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class TimestampMixin:
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

// 사용자 모델 예시 (src/models/user.py)
```python
from .base import db, TimestampMixin

class User(db.Model, TimestampMixin):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(255), nullable=False)
    name = db.Column(db.String(100), nullable=False)
    deleted_at = db.Column(db.DateTime, nullable=True)

    @property
    def is_deleted(self):
        return self.deleted_at is not None
```

// 자기 참조 관계 예시 (src/models/comment.py)
```python
class Comment(db.Model, TimestampMixin):
    __tablename__ = 'comments'
    
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    post_id = db.Column(db.Integer, db.ForeignKey('posts.id'), nullable=False)
    parent_id = db.Column(db.Integer, db.ForeignKey('comments.id'), nullable=True)
    
    # 자기 참조 관계 (대댓글)
    replies = db.relationship('Comment', 
                            backref=db.backref('parent', remote_side=[id]),
                            lazy='dynamic')
```

// API 엔드포인트 설계
- 버전 관리를 통한 하위 호환성 보장 (/v1/...)
- 관리자 전용 엔드포인트 분리 (/admin/...)
- 표준 RESTful API 설계 원칙 준수
- JWT 기반 인증 및 권한 관리 

// 인증 라우트 예시 (src/routes/v1/auth_routes.py)
```python
from flask import Blueprint, request, jsonify
from src.services.auth_service import AuthService

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/register', methods=['POST'])
def register():
    data = request.get_json()
    
    try:
        user = AuthService.register(data)
        access_token = AuthService.create_access_token(user)
        
        return jsonify({
            "access_token": access_token,
            "token_type": "bearer"
        }), 201
        
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
```

// 인증 미들웨어 예시 (src/utils/auth.py)
```python
from functools import wraps
from flask import request, jsonify
import jwt
from src.models import User
from src.config.env import SECRET_KEY

# JWT 토큰 검증을 위한 데코레이터
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            try:
                token = auth_header.split(" ")[1]
            except IndexError:
                return jsonify({'error': '유효하지 않은 토큰 형식입니다'}), 401

        if not token:
            return jsonify({'error': '토큰이 필요합니다'}), 401

        try:
            data = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
            current_user = User.query.get(data['user_id'])
            
            # 유저가 존재하지 않거나 삭제된 경우 확인
            if not current_user:
                return jsonify({'error': '존재하지 않는 사용자입니다'}), 401
            
            if current_user.is_deleted:
                return jsonify({'error': '삭제된 사용자입니다'}), 401
                
        except:
            return jsonify({'error': '유효하지 않은 토큰입니다'}), 401

        return f(current_user, *args, **kwargs)

    return decorated
```

// 보안 관련 설계
- 비밀번호 해싱 처리
- 토큰 기반 인증
- 환경별 보안 설정 분리

// 비밀번호 해싱 예시 (src/services/auth_service.py)
```python
import bcrypt
import jwt
from datetime import datetime, timedelta
from src.models import User, db
from src.config.env import SECRET_KEY

class AuthService:
    @staticmethod
    def hash_password(password):
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')
    
    @staticmethod
    def check_password(hashed_password, plain_password):
        return bcrypt.checkpw(plain_password.encode('utf-8'), hashed_password.encode('utf-8'))
    
    @staticmethod
    def create_access_token(user):
        payload = {
            'user_id': user.id,
            'exp': datetime.utcnow() + timedelta(hours=24)
        }
        return jwt.encode(payload, SECRET_KEY, algorithm="HS256")
```

// 확장성을 위한 설계
- 코드 모듈화 및 분리로 유지보수성 향상
- 마이그레이션 시스템을 통한 DB 스키마 버전 관리
- 서버리스 아키텍처로 인한 자동 확장성

// 환경 설정 예시 (src/config/env.py)
```python
import os
from dotenv import load_dotenv

# 적절한 환경 변수 로드
if os.path.exists('.env.local'):
    load_dotenv('.env.local')
elif os.path.exists('.env.prod'):
    load_dotenv('.env.prod')
else:
    load_dotenv('.env')

# 환경 변수 가져오기
FLASK_ENV = os.getenv('FLASK_ENV', 'development')
DEBUG = FLASK_ENV == 'development'
SECRET_KEY = os.getenv('SECRET_KEY', 'your-secret-key')
DATABASE_URI = os.getenv('DATABASE_URI')
```

// 멀티테넌트 설계 패턴
- 사용자와 콘텐츠에 소속 정보 연결 (학교, 단과대, 학부 등)
- 소속별 콘텐츠 격리 및 접근 제어
- 계층적 소속 구조 관리 (국가-학교-단과대-학부)

// 계층적 소속 구조 예시 (src/models/organization.py)
```python
class Organization(db.Model, TimestampMixin):
    __tablename__ = 'organizations'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    parent_id = db.Column(db.Integer, db.ForeignKey('organizations.id'), nullable=True)
    
    # 자기 참조 관계
    children = db.relationship('Organization', 
                              backref=db.backref('parent', remote_side=[id]),
                              lazy='dynamic')
    
    # 사용자 관계
    users = db.relationship('User', backref='organization', lazy=True)
    
    # 콘텐츠 관계
    posts = db.relationship('Post', backref='organization', lazy=True)
```

// 익명성 구현 패턴
- 사용자 실제 정보와 표시 정보 분리
- 컨텍스트별 일관된, 무작위 식별자 할당 (랜덤 닉네임)
- 컨텍스트간 서로 다른 식별자 제공으로 익명성 강화

// 익명 사용자 서비스 예시 (src/services/nickname_service.py)
```python
import random
from src.models import Nickname, db

class NicknameService:
    @staticmethod
    def get_random_nickname():
        # 랜덤 닉네임 풀에서 무작위 선택
        nicknames_count = Nickname.query.count()
        if nicknames_count == 0:
            return "익명사용자"
            
        random_offset = random.randint(0, nicknames_count - 1)
        random_nickname = Nickname.query.offset(random_offset).first()
        return random_nickname.nickname
    
    @staticmethod
    def get_consistent_nickname(user_id, context_id):
        """특정 컨텍스트 내에서 일관된 닉네임 제공"""
        # user_id와 context_id의 해시를 기반으로 일관된 닉네임 제공
        combined_hash = hash((user_id, context_id)) % 1000
        nicknames_count = Nickname.query.count()
        
        if nicknames_count == 0:
            return "익명사용자"
            
        nickname_index = combined_hash % nicknames_count
        consistent_nickname = Nickname.query.offset(nickname_index).first()
        return consistent_nickname.nickname
```

// 콘텐츠 관리 정책
- 삭제된 콘텐츠의 표시 방식 정의
- 사용자 탈퇴 시 연관 콘텐츠 처리 방식
- 커뮤니티 기반 콘텐츠 관리 (좋아요, 댓글 등)

// 게시글 서비스 예시 (src/services/post_service.py)
```python
from datetime import datetime
from src.models import Post, db

class PostService:
    @staticmethod
    def create_post(data, user_id):
        new_post = Post(
            title=data['title'],
            content=data['content'],
            user_id=user_id,
            # 기타 필드
        )
        db.session.add(new_post)
        db.session.commit()
        return new_post
    
    @staticmethod
    def soft_delete_post(post_id):
        post = Post.query.get(post_id)
        if not post:
            raise ValueError("게시글이 존재하지 않습니다")
            
        post.deleted_at = datetime.utcnow()
        db.session.commit()
        return True
    
    @staticmethod
    def get_post_with_details(post_id):
        post = Post.query.get(post_id)
        if not post:
            raise ValueError("게시글이 존재하지 않습니다")
            
        if post.is_deleted:
            # 삭제된 게시글 처리
            return {
                "id": post.id,
                "title": "삭제된 게시글입니다",
                "content": "삭제된 게시글입니다",
                "user_nickname": post.user_nickname,
                "created_at": post.created_at
            }
            
        # 정상 게시글 처리
        return {
            "id": post.id,
            "title": post.title,
            "content": post.content,
            "user_nickname": post.user_nickname,
            "created_at": post.created_at,
            # 기타 필드
        }
```

// 응답 데이터 포맷팅 (src/utils/formatters.py)
```python
from datetime import datetime

def get_country_data(country):
    return {
        'id': country.id,
        'name': country.name,
        'code': country.code,
    }

def get_school_data(school):
    return {
        'id': school.id,
        'name': school.name,
    }

def get_college_data(college):
    return {
        'id': college.id,
        'name': college.name,
    }

def get_department_data(department):
    return {
        'id': department.id,
        'name': department.name,
    }

def get_post_data(post, view_count, comment_count, like_count, dislike_count, user_like_status=None, user_dislike_status=None):
    """게시글 데이터를 포맷팅합니다."""
    # 삭제된 게시글인 경우
    if post.deleted_at:
        return {
            'id': post.id,
            'title': None,
            'content': None,
            'category': post.category,
            'user': None,
            'nickname': None,
            'school': {
                'id': post.school.id,
                'name': post.school.name
            },
            'college': {
                'id': post.college.id,
                'name': post.college.name
            },
            'department': {
                'id': post.department.id,
                'name': post.department.name
            },
            'view_count': view_count,
            'comment_count': comment_count,
            'like_count': like_count,
            'dislike_count': dislike_count,
            'user_like_status': user_like_status,
            'user_dislike_status': user_dislike_status,
            'created_at': post.created_at.isoformat(),
            'updated_at': post.updated_at.isoformat(),
            'deleted_at': post.deleted_at.isoformat() if post.deleted_at else None
        }
    
    # 정상 게시글 포맷팅
    return {
        'id': post.id,
        'title': post.title,
        'content': post.content,
        'category': post.category,
        'user': get_current_user_data(post.user) if post.user else None,
        'nickname': post.nickname,
        'school': {
            'id': post.school.id,
            'name': post.school.name
        },
        'college': {
            'id': post.college.id,
            'name': post.college.name
        },
        'department': {
            'id': post.department.id,
            'name': post.department.name
        },
        'view_count': view_count,
        'comment_count': comment_count,
        'like_count': like_count,
        'dislike_count': dislike_count,
        'user_like_status': user_like_status,
        'user_dislike_status': user_dislike_status,
        'created_at': post.created_at.isoformat(),
        'updated_at': post.updated_at.isoformat(),
        'deleted_at': None
    }

def get_comment_data(comment, reply_count):
    # 삭제된 댓글인 경우
    if comment.deleted_at:
        return {
            'id': comment.id,
            'content': None,
            'nickname': None,
            'parent_id': comment.parent_id,
            'post_id': comment.post_id,
            'reply_count': reply_count,
            'created_at': comment.created_at.isoformat(),
            'updated_at': comment.updated_at.isoformat(),
            'deleted_at': comment.deleted_at.isoformat() 
        }
    
    # 정상 댓글 포맷팅
    return {
        'id': comment.id,
        'content': comment.content,
        'user': get_user_data(comment.user),
        'nickname': comment.nickname,
        'parent_id': comment.parent_id,
        'post_id': comment.post_id,
        'reply_count': reply_count,
        'created_at': comment.created_at.isoformat(),
        'updated_at': comment.updated_at.isoformat(),
        'deleted_at': None
    }

def get_user_data(user):
    # 삭제된 사용자인 경우
    if user.is_deleted:
        return {
            'id': user.id,
            'country': None,
            'school': None,
            'college': None,
            'department': None,
            'deleted_at': user.deleted_at.isoformat() if user.deleted_at else None
        }
    
    # 정상 사용자 정보 포맷팅
    return {
        'id': user.id,
        'country': {
            'id': user.country.id,
            'name': user.country.name,
            'code': user.country.code
        },
        'school': {
            'id': user.school.id,
            'name': user.school.name
        },
        'college': {
            'id': user.college.id,
            'name': user.college.name
        },
        'department': {
            'id': user.department.id,
            'name': user.department.name
        },
        'deleted_at': user.deleted_at.isoformat() if user.deleted_at else None
    }

def get_current_user_data(user):
    # 현재 로그인한 사용자 정보 포맷팅
    return {
        'id': user.id,
        'email': user.email,
        'name': user.name,
        'country': {
            'id': user.country.id,
            'name': user.country.name,
            'code': user.country.code
        },
        'school': {
            'id': user.school.id,
            'name': user.school.name
        },
        'college': {
            'id': user.college.id,
            'name': user.college.name
        },
        'department': {
            'id': user.department.id,
            'name': user.department.name
        },
        'created_at': user.created_at.isoformat(),
        'updated_at': user.updated_at.isoformat()
    }
```